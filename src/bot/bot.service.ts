import { Injectable } from '@nestjs/common';
import { Telegraf, Markup, Context } from 'telegraf';
import { Update } from 'telegraf/typings/core/types/typegram';
import { ConfigService } from '@nestjs/config';
import { questions } from './questions';
import { questionsTest2 } from './question2';

interface UserSession {
  currentQuestion: number;
  answers: Record<string, string>;
  testType: '–ù–∞ —Å–∫–æ–ª—å–∫–æ –≤—ã –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω—ã –æ –ú–¢–î' | '–¢–µ—Å—Ç –Ω–∞ –î–ú–¢–î';
}

interface CustomContext extends Context<Update> {
  match: RegExpMatchArray;
}

@Injectable()
export class BotService {
  private bot: Telegraf;
  private userSessions: Record<number, UserSession> = {};

  constructor(private configService: ConfigService) {
    console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è BotService...');

    const botToken = this.configService.get<string>('BOT_TOKEN');
    if (!botToken) {
      throw new Error('BOT_TOKEN –Ω–µ —É–∫–∞–∑–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è');
    }
    this.bot = new Telegraf(botToken);

    // –ù–∞—Å—Ç—Ä–æ–∏–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    this.setupHandlers();

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    process.once('SIGINT', () => this.bot.stop('SIGINT'));
    process.once('SIGTERM', () => this.bot.stop('SIGTERM'));
  }

  public async handleUpdate(update: Update): Promise<void> {
    await this.bot.handleUpdate(update);
  }

  private async setupHandlers() {
    // –°—Ç–∞—Ä—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    this.bot.start(async (ctx: Context) => {
      const userName = ctx.from?.first_name || '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å';
      await ctx.reply(
        `–ü—Ä–∏–≤–µ—Ç, ${userName}! –í—ã–±–µ—Ä–∏ —Ç–µ—Å—Ç:`,
        Markup.keyboard([
          ['–ù–∞ —Å–∫–æ–ª—å–∫–æ –≤—ã –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω—ã –æ –ú–¢–î', '–¢–µ—Å—Ç –Ω–∞ –î–ú–¢–î'],
          ['–ö—É–ø–∏—Ç—å –≥–∞–π–¥'],
        ]).resize(),
      );
    });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã –Ω–∞ —Ç–µ—Å—Ç "–ù–∞ —Å–∫–æ–ª—å–∫–æ –≤—ã –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω—ã –æ –ú–¢–î"
    this.bot.hears('–ù–∞ —Å–∫–æ–ª—å–∫–æ –≤—ã –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω—ã –æ –ú–¢–î', async (ctx: Context) => {
      const userId = ctx.from?.id;
      if (!userId) return;

      delete this.userSessions[userId];
      this.userSessions[userId] = {
        currentQuestion: 0,
        answers: {},
        testType: '–ù–∞ —Å–∫–æ–ª—å–∫–æ –≤—ã –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω—ã –æ –ú–¢–î',
      };
      await this.sendQuestion(ctx);
    });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã –Ω–∞ —Ç–µ—Å—Ç "–¢–µ—Å—Ç –Ω–∞ –î–ú–¢–î"
    this.bot.hears('–¢–µ—Å—Ç –Ω–∞ –î–ú–¢–î', async (ctx: Context) => {
      const userId = ctx.from?.id;
      if (!userId) return;

      delete this.userSessions[userId];
      this.userSessions[userId] = {
        currentQuestion: 0,
        answers: {},
        testType: '–¢–µ—Å—Ç –Ω–∞ –î–ú–¢–î',
      };
      await this.sendQuestion(ctx);
    });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–∫–∏ "–ö—É–ø–∏—Ç—å –≥–∞–π–¥"
    this.bot.hears('–ö—É–ø–∏—Ç—å –≥–∞–π–¥', async (ctx: Context) => {
      await this.sendGuide(ctx);
    });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    this.bot.action(/.*/, async (ctx: CustomContext) => {
      const userId = ctx.from?.id;
      if (!userId || !this.userSessions[userId]) return;

      const userAnswer = ctx.match[0];
      const session = this.userSessions[userId];
      const currentTest =
        session.testType === '–ù–∞ —Å–∫–æ–ª—å–∫–æ –≤—ã –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω—ã –æ –ú–¢–î'
          ? questions
          : questionsTest2;
      const currentQuestion = currentTest[session.currentQuestion];

      session.answers[currentQuestion.text] = userAnswer;
      session.currentQuestion++;

      if (session.currentQuestion >= currentTest.length) {
        if (session.testType === '–¢–µ—Å—Ç –Ω–∞ –î–ú–¢–î') {
          const yesCount = Object.values(session.answers).filter(
            (answer) => answer.toLowerCase() === '–¥–∞',
          ).length;
          await this.sendTest2Result(ctx, yesCount);
        } else {
          await this.handleTestCompletion(ctx);
        }
        delete this.userSessions[userId];
        return;
      }

      await this.sendQuestion(ctx);
    });

    // –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    try {
      await this.bot.launch();
      console.log('–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!');
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞:', error);
    }
  }

  private async sendQuestion(ctx: Context) {
    const userId = ctx.from?.id;
    if (!userId || !this.userSessions[userId]) return;

    const session = this.userSessions[userId];
    const currentTest =
      session.testType === '–ù–∞ —Å–∫–æ–ª—å–∫–æ –≤—ã –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω—ã –æ –ú–¢–î'
        ? questions
        : questionsTest2;
    const question = currentTest[session.currentQuestion];

    const keyboard = Markup.inlineKeyboard(
      question.options.map((option) => [
        Markup.button.callback(option, option),
      ]),
    );

    await ctx.reply(question.text, keyboard);
  }

  private async sendTest2Result(ctx: Context, yesCount: number) {
    let resultMessage = `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–≤–µ—Ç–æ–≤ "–î–∞": ${yesCount}\n\n`;

    if (yesCount <= 3) {
      resultMessage += 'üîπ 0‚Äì3 ¬´–î–∞¬ª ‚Äì –í—Å—ë –æ–∫!';
    } else if (yesCount <= 7) {
      resultMessage += 'üîπ 4‚Äì7 ¬´–î–∞¬ª ‚Äì –í–æ–∑–º–æ–∂–Ω—ã –Ω–∞—á–∞–ª—å–Ω—ã–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è.';
    } else if (yesCount <= 12) {
      resultMessage += 'üîπ 8‚Äì12 ¬´–î–∞¬ª ‚Äì –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫.';
    } else {
      resultMessage += 'üîπ 13+ ¬´–î–∞¬ª ‚Äì –°–µ—Ä—å—ë–∑–Ω—ã–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è.';
    }

    resultMessage += '\n\n–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏ –≥–∞–π–¥:';

    await ctx.reply(
      resultMessage,
      Markup.inlineKeyboard([
        [
          Markup.button.url(
            '–ö—É–ø–∏—Ç—å –∑–∞ 911 —Ä—É–±–ª–µ–π',
            'https://t.me/k_nazarovaaa',
          ),
        ],
        [Markup.button.callback('–£–∑–Ω–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω–µ–µ', 'show_guide_details')],
      ]),
    );

    await ctx.reply(
      '–•–æ—Ç–∏—Ç–µ –ø—Ä–æ–π—Ç–∏ —Ç–µ—Å—Ç –µ—â–µ —Ä–∞–∑?',
      Markup.keyboard([
        ['–ù–∞ —Å–∫–æ–ª—å–∫–æ –≤—ã –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω—ã –æ –ú–¢–î', '–¢–µ—Å—Ç –Ω–∞ –î–ú–¢–î'],
        ['–ö—É–ø–∏—Ç—å –≥–∞–π–¥'],
      ]).resize(),
    );
  }

  private async handleTestCompletion(ctx: Context) {
    await ctx.reply(
      '–ï—Å–ª–∏ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –≤–æ–ø—Ä–æ—Å –∑–∞—Å—Ç–∞–≤–∏–ª –≤–∞—Å –∑–∞–¥—É–º–∞—Ç—å—Å—è, —É–≤–µ—Ä–µ–Ω–∞: –≤–∞–º –±—É–¥–µ—Ç –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ —É –º–µ–Ω—è –≤ —Ç–≥-–∫–∞–Ω–∞–ª–µ:',
      Markup.inlineKeyboard([
        [Markup.button.url('–ü–µ—Ä–µ–π—Ç–∏ –≤ –∫–∞–Ω–∞–ª', 'https://t.me/softPower_yoga')],
        [
          Markup.button.url(
            '–ö—É–ø–∏—Ç—å –≥–∞–π–¥ –∑–∞ 911 —Ä—É–±–ª–µ–π',
            'https://t.me/k_nazarovaaa',
          ),
        ],
        [Markup.button.callback('–£–∑–Ω–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω–µ–µ', 'show_guide_details')],
      ]),
    );

    await ctx.reply(
      '–•–æ—Ç–∏—Ç–µ –ø—Ä–æ–π—Ç–∏ —Ç–µ—Å—Ç –µ—â–µ —Ä–∞–∑?',
      Markup.keyboard([
        ['–ù–∞ —Å–∫–æ–ª—å–∫–æ –≤—ã –æ—Å–≤–µ–¥–æ–º–ª–µ–Ω—ã –æ –ú–¢–î', '–¢–µ—Å—Ç –Ω–∞ –î–ú–¢–î'],
        ['–ö—É–ø–∏—Ç—å –≥–∞–π–¥'],
      ]).resize(),
    );
  }

  private async sendGuide(ctx: Context) {
    const guideText = `–ì–ê–ô–î ¬´–ñ–ò–ó–ù–¨ –° –î–ò–°–§–£–ù–ö–¶–ò–Ø–ú–ò –ú–´–®–¶ –¢–ê–ó–û–í–û–ì–û –î–ù–ê¬ª ...\n\nüí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å –≥–∞–π–¥–∞: 911 —Ä—É–±–ª–µ–π`;

    try {
      await ctx.replyWithPhoto(
        { source: './src/assets/card.jpg' },
        {
          caption: guideText,
          ...Markup.inlineKeyboard([
            [
              Markup.button.url(
                '–ö—É–ø–∏—Ç—å –∑–∞ 911 —Ä—É–±–ª–µ–π',
                'https://t.me/k_nazarovaaa',
              ),
            ],
          ]),
        },
      );
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–æ—Ç–æ:', error);
      await ctx.reply(guideText);
    }
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook
  public async setWebhook(url: string): Promise<void> {
    try {
      await this.bot.telegram.setWebhook(url);
      console.log(`Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞: ${url}`);
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ webhook:', error);
    }
  }
}
